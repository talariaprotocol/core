{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/helpers/MerkleTreeWithHistory.sol": {
      "content": "// https://tornado.cash\n/*\n * d888888P                                           dP              a88888b.                   dP\n *    88                                              88             d8'   `88                   88\n *    88    .d8888b. 88d888b. 88d888b. .d8888b. .d888b88 .d8888b.    88        .d8888b. .d8888b. 88d888b.\n *    88    88'  `88 88'  `88 88'  `88 88'  `88 88'  `88 88'  `88    88        88'  `88 Y8ooooo. 88'  `88\n *    88    88.  .88 88       88    88 88.  .88 88.  .88 88.  .88 dP Y8.   .88 88.  .88       88 88    88\n *    dP    `88888P' dP       dP    dP `88888P8 `88888P8 `88888P' 88  Y88888P' `88888P8 `88888P' dP    dP\n * ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IHasher {\n  function MiMCSponge(uint256 in_xL, uint256 in_xR) external pure returns (uint256 xL, uint256 xR);\n}\n\ncontract MerkleTreeWithHistory {\n  uint256 public constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n  uint256 public constant ZERO_VALUE = 21663839004416932945382355908790599225266501822907911457504978515578255421292; // = keccak256(\"tornado\") % FIELD_SIZE\n  IHasher public immutable hasher;\n\n  uint32 public levels;\n\n  // the following variables are made public for easier testing and debugging and\n  // are not supposed to be accessed in regular code\n\n  // filledSubtrees and roots could be bytes32[size], but using mappings makes it cheaper because\n  // it removes index range check on every interaction\n  mapping(uint256 => bytes32) public filledSubtrees;\n  mapping(uint256 => bytes32) public roots;\n  uint32 public constant ROOT_HISTORY_SIZE = 30;\n  uint32 public currentRootIndex = 0;\n  uint32 public nextIndex = 0;\n\n  constructor(uint32 _levels, IHasher _hasher) {\n    require(_levels > 0, \"_levels should be greater than zero\");\n    require(_levels < 32, \"_levels should be less than 32\");\n    levels = _levels;\n    hasher = _hasher;\n\n    for (uint32 i = 0; i < _levels; i++) {\n      filledSubtrees[i] = zeros(i);\n    }\n\n    roots[0] = zeros(_levels - 1);\n  }\n\n  /**\n    @dev Hash 2 tree leaves, returns MiMC(_left, _right)\n  */\n  function hashLeftRight(\n    IHasher _hasher,\n    bytes32 _left,\n    bytes32 _right\n  ) public pure returns (bytes32) {\n    require(uint256(_left) < FIELD_SIZE, \"_left should be inside the field\");\n    require(uint256(_right) < FIELD_SIZE, \"_right should be inside the field\");\n    uint256 R = uint256(_left);\n    uint256 C = 0;\n    (R, C) = _hasher.MiMCSponge(R, C);\n    R = addmod(R, uint256(_right), FIELD_SIZE);\n    (R, C) = _hasher.MiMCSponge(R, C);\n    return bytes32(R);\n  }\n\n  function _insert(bytes32 _leaf) internal returns (uint32 index) {\n    uint32 _nextIndex = nextIndex;\n    require(_nextIndex != uint32(2)**levels, \"Merkle tree is full. No more leaves can be added\");\n    uint32 currentIndex = _nextIndex;\n    bytes32 currentLevelHash = _leaf;\n    bytes32 left;\n    bytes32 right;\n\n    for (uint32 i = 0; i < levels; i++) {\n      if (currentIndex % 2 == 0) {\n        left = currentLevelHash;\n        right = zeros(i);\n        filledSubtrees[i] = currentLevelHash;\n      } else {\n        left = filledSubtrees[i];\n        right = currentLevelHash;\n      }\n      currentLevelHash = hashLeftRight(hasher, left, right);\n      currentIndex /= 2;\n    }\n\n    uint32 newRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;\n    currentRootIndex = newRootIndex;\n    roots[newRootIndex] = currentLevelHash;\n    nextIndex = _nextIndex + 1;\n    return _nextIndex;\n  }\n\n  /**\n    @dev Whether the root is present in the root history\n  */\n  function isKnownRoot(bytes32 _root) public view returns (bool) {\n    if (_root == 0) {\n      return false;\n    }\n    uint32 _currentRootIndex = currentRootIndex;\n    uint32 i = _currentRootIndex;\n    do {\n      if (_root == roots[i]) {\n        return true;\n      }\n      if (i == 0) {\n        i = ROOT_HISTORY_SIZE;\n      }\n      i--;\n    } while (i != _currentRootIndex);\n    return false;\n  }\n\n  /**\n    @dev Returns the last root\n  */\n  function getLastRoot() public view returns (bytes32) {\n    return roots[currentRootIndex];\n  }\n\n  /// @dev provides Zero (Empty) elements for a MiMC MerkleTree. Up to 32 levels\n  function zeros(uint256 i) public pure returns (bytes32) {\n    if (i == 0) return bytes32(0x2fe54c60d3acabf3343a35b6eba15db4821b340f76e741e2249685ed4899af6c);\n    else if (i == 1) return bytes32(0x256a6135777eee2fd26f54b8b7037a25439d5235caee224154186d2b8a52e31d);\n    else if (i == 2) return bytes32(0x1151949895e82ab19924de92c40a3d6f7bcb60d92b00504b8199613683f0c200);\n    else if (i == 3) return bytes32(0x20121ee811489ff8d61f09fb89e313f14959a0f28bb428a20dba6b0b068b3bdb);\n    else if (i == 4) return bytes32(0x0a89ca6ffa14cc462cfedb842c30ed221a50a3d6bf022a6a57dc82ab24c157c9);\n    else if (i == 5) return bytes32(0x24ca05c2b5cd42e890d6be94c68d0689f4f21c9cec9c0f13fe41d566dfb54959);\n    else if (i == 6) return bytes32(0x1ccb97c932565a92c60156bdba2d08f3bf1377464e025cee765679e604a7315c);\n    else if (i == 7) return bytes32(0x19156fbd7d1a8bf5cba8909367de1b624534ebab4f0f79e003bccdd1b182bdb4);\n    else if (i == 8) return bytes32(0x261af8c1f0912e465744641409f622d466c3920ac6e5ff37e36604cb11dfff80);\n    else if (i == 9) return bytes32(0x0058459724ff6ca5a1652fcbc3e82b93895cf08e975b19beab3f54c217d1c007);\n    else if (i == 10) return bytes32(0x1f04ef20dee48d39984d8eabe768a70eafa6310ad20849d4573c3c40c2ad1e30);\n    else if (i == 11) return bytes32(0x1bea3dec5dab51567ce7e200a30f7ba6d4276aeaa53e2686f962a46c66d511e5);\n    else if (i == 12) return bytes32(0x0ee0f941e2da4b9e31c3ca97a40d8fa9ce68d97c084177071b3cb46cd3372f0f);\n    else if (i == 13) return bytes32(0x1ca9503e8935884501bbaf20be14eb4c46b89772c97b96e3b2ebf3a36a948bbd);\n    else if (i == 14) return bytes32(0x133a80e30697cd55d8f7d4b0965b7be24057ba5dc3da898ee2187232446cb108);\n    else if (i == 15) return bytes32(0x13e6d8fc88839ed76e182c2a779af5b2c0da9dd18c90427a644f7e148a6253b6);\n    else if (i == 16) return bytes32(0x1eb16b057a477f4bc8f572ea6bee39561098f78f15bfb3699dcbb7bd8db61854);\n    else if (i == 17) return bytes32(0x0da2cb16a1ceaabf1c16b838f7a9e3f2a3a3088d9e0a6debaa748114620696ea);\n    else if (i == 18) return bytes32(0x24a3b3d822420b14b5d8cb6c28a574f01e98ea9e940551d2ebd75cee12649f9d);\n    else if (i == 19) return bytes32(0x198622acbd783d1b0d9064105b1fc8e4d8889de95c4c519b3f635809fe6afc05);\n    else if (i == 20) return bytes32(0x29d7ed391256ccc3ea596c86e933b89ff339d25ea8ddced975ae2fe30b5296d4);\n    else if (i == 21) return bytes32(0x19be59f2f0413ce78c0c3703a3a5451b1d7f39629fa33abd11548a76065b2967);\n    else if (i == 22) return bytes32(0x1ff3f61797e538b70e619310d33f2a063e7eb59104e112e95738da1254dc3453);\n    else if (i == 23) return bytes32(0x10c16ae9959cf8358980d9dd9616e48228737310a10e2b6b731c1a548f036c48);\n    else if (i == 24) return bytes32(0x0ba433a63174a90ac20992e75e3095496812b652685b5e1a2eae0b1bf4e8fcd1);\n    else if (i == 25) return bytes32(0x019ddb9df2bc98d987d0dfeca9d2b643deafab8f7036562e627c3667266a044c);\n    else if (i == 26) return bytes32(0x2d3c88b23175c5a5565db928414c66d1912b11acf974b2e644caaac04739ce99);\n    else if (i == 27) return bytes32(0x2eab55f6ae4e66e32c5189eed5c470840863445760f5ed7e7b69b2a62600f354);\n    else if (i == 28) return bytes32(0x002df37a2642621802383cf952bf4dd1f32e05433beeb1fd41031fb7eace979d);\n    else if (i == 29) return bytes32(0x104aeb41435db66c3e62feccc1d6f5d98d0a0ed75d1374db457cf462e3a1f427);\n    else if (i == 30) return bytes32(0x1f3c6fd858e9a7d4b0d1f38e256a09d81d5a5e3c963987e2d4b814cfab7c6ebb);\n    else if (i == 31) return bytes32(0x2c7a07d20dff79d01fecedc1134284a8d08436606c93693b67e333f671bf69cc);\n    else revert(\"Index out of bounds\");\n  }\n}\n"
    },
    "contracts/modules/IValidationModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IValidationModule {\n  function validate(bytes calldata arg) external returns (bool);\n}"
    },
    "contracts/TalariaProtocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./helpers/MerkleTreeWithHistory.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"./modules/IValidationModule.sol\";\n\ninterface IVerifier {\n  function verifyProof(bytes memory _proof, uint256[6] memory _input) external returns (bool);\n}\n\ncontract TalariaProtocol is MerkleTreeWithHistory, ReentrancyGuard {\n  IVerifier public immutable verifier;\n \n  mapping(bytes32 => bool) public nullifierHashes;\n  // we store all commitments just to prevent accidental creations with the same commitment\n  mapping(bytes32 => bool) public commitments;\n\n  // commitments to validation modules \n  mapping(bytes32 => address[]) public validationModules;\n\n  event NewCode(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp);\n  event ConsumeCode(address to, bytes32 nullifierHash, uint256 timestamp);\n\n  /**\n    @dev The constructor\n    @param _verifier the address of SNARK verifier for this contract\n    @param _hasher the address of MiMC hash contract\n    @param _merkleTreeHeight the height of codes' Merkle Tree\n  */\n  constructor(\n    IVerifier _verifier,\n    IHasher _hasher,\n    uint32 _merkleTreeHeight\n  ) MerkleTreeWithHistory(_merkleTreeHeight, _hasher) {\n    verifier = _verifier;\n  }\n\n  /**\n    @dev Set new code.\n    @param _commitment the note commitment, which is PedersenHash(nullifier + secret)\n  */\n  function setCode(bytes32 _commitment, address[] calldata _validationModules) public virtual payable nonReentrant {\n    require(!commitments[_commitment], \"The commitment has been submitted\");\n\n    uint32 insertedIndex = _insert(_commitment);\n    commitments[_commitment] = true;\n\n    for (uint256 i = 0; i < _validationModules.length; i++) {\n      validationModules[_commitment].push(_validationModules[i]);\n    }\n\n    emit NewCode(_commitment, insertedIndex, block.timestamp);\n  }\n\n\n  /**\n    @dev Consume a code from the contract. `proof` is a zkSNARK proof data, and input is an array of circuit public inputs\n    `input` array consists of:\n      - merkle root of all codes in the contract\n      - hash of unique codes nullifier to prevent double spends\n      - the recipient of funds\n      - optional fee that goes to the transaction sender (usually a relay)\n  */\n  function consumeCode(\n    bytes32 _commitment,\n    bytes memory _proof,\n    bytes32 _root,\n    bytes32 _nullifierHash,\n    address payable _recipient,\n    bytes[] memory _validationsArgs\n  ) public virtual payable nonReentrant {\n    require(!nullifierHashes[_nullifierHash], \"The note has been already spent\");\n    require(isKnownRoot(_root), \"Cannot find your merkle root\"); // Make sure to use a recent one\n        \n    require(\n      verifier.verifyProof(\n        _proof,\n        [uint256(_root), uint256(_nullifierHash), uint256(uint160(address(_recipient))),0 ,0, 0]\n      ),\n      \"Invalid withdraw proof\"\n    );\n\n    for (uint256 i = 0; i < validationModules[_commitment].length; i++) {\n      IValidationModule(validationModules[_commitment][i]).validate(_validationsArgs[i]);\n    }\n\n    nullifierHashes[_nullifierHash] = true;\n\n    emit ConsumeCode(_recipient, _nullifierHash, block.timestamp);\n  }\n\n  /** @dev whether a note is already spent */\n  function isSpent(bytes32 _nullifierHash) public view returns (bool) {\n    return nullifierHashes[_nullifierHash];\n  }\n\n  /** @dev whether an array of notes is already spent */\n  function isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent) {\n    spent = new bool[](_nullifierHashes.length);\n    for (uint256 i = 0; i < _nullifierHashes.length; i++) {\n      if (isSpent(_nullifierHashes[i])) {\n        spent[i] = true;\n      }\n    }\n  }\n}\n"
    },
    "contracts/useCases/TalariaFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n\nimport {IHasher} from \"../helpers/MerkleTreeWithHistory.sol\";\nimport {TalariaProtocol, IVerifier} from \"../../contracts/TalariaProtocol.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nabstract contract TalariaFactory is Ownable {\n    IVerifier defaultVerifier;\n    IHasher defaultHasher;\n    uint32 defaultMerkleTreeHeight;\n    \n    constructor(\n        IVerifier _verifier,\n        IHasher _hasher,\n        uint32 _merkleTreeHeight\n    ) Ownable(msg.sender) {\n        defaultVerifier = _verifier;\n        defaultHasher = _hasher;\n        defaultMerkleTreeHeight = _merkleTreeHeight;\n    }\n\n    function changeDefaultVerifier(IVerifier _newVerifier) external onlyOwner {\n        defaultVerifier = _newVerifier;\n    }\n\n    function changeDefaultHasher(IHasher _newHasher) external onlyOwner {\n        defaultHasher = _newHasher;\n    }   \n\n    function changeDefaultMerkleTreeHeight(uint32 _newMerkleTreeHeight) external onlyOwner {\n        defaultMerkleTreeHeight = _newMerkleTreeHeight;\n    }\n\n    function createTalariaInstance() public returns (TalariaProtocol) {\n        return new TalariaProtocol(defaultVerifier, defaultHasher, defaultMerkleTreeHeight);\n    }\n\n    /*\n    * @dev Creates a new Talaria instance and returns the address\n    */\n    function create() virtual external returns (address);       \n}"
    },
    "contracts/useCases/whitelist/Whitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../../TalariaProtocol.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Whitelist is Ownable, TalariaProtocol{\n\n  mapping(address => bool) public usersWhitelisted;\n\n  event UserAddedToWhitelist(address indexed user, uint256 timestamp);\n  event UserRemovedFromWhitelist(address indexed user, uint256 timestamp);\n\n  constructor(\n    IVerifier _verifier,\n    IHasher _hasher,\n    uint32 _merkleTreeHeight,\n    address _owner\n  ) TalariaProtocol(_verifier, _hasher, _merkleTreeHeight\n  ) Ownable(_owner) {\n  }\n\n  function createEarlyAccessCode(bytes32 _commitment, address[] calldata _validationModules) public onlyOwner payable {\n    setCode(_commitment, _validationModules);\n  }\n\n  function consumeEarlyAccessCode(\n    bytes32 _commitment,\n    bytes calldata _proof,\n    bytes32 _root,\n    bytes32 _nullifierHash,\n    address payable _to,\n    bytes[] calldata _validationsArgs,\n    address userToWhitelist\n  ) public {\n    require(!usersWhitelisted[userToWhitelist], \"User already whitelisted\");\n\n    consumeCode(_commitment,_proof, _root, _nullifierHash, _to, _validationsArgs);\n\n    usersWhitelisted[userToWhitelist] = true;\n  }\n\n  function bulkCreateEarlyAccessCodes(bytes32[] calldata _commitments, address[][] calldata _validationModules) public payable {\n    for (uint256 i = 0; i < _commitments.length; i++) {\n      createEarlyAccessCode(_commitments[i], _validationModules[i]);\n    }\n  }\n\n  function bulkConsumeEarlyAccessCodes(\n    bytes32[] calldata _commitments,\n    bytes[] calldata _proofs,\n    bytes32[] calldata _roots,\n    bytes32[] calldata _nullifierHashes,\n    address payable[] calldata _tos,\n    bytes[] calldata _validationsArgs,\n    address[] calldata _usersToWhitelist\n  ) public {\n    for (uint256 i = 0; i < _commitments.length; i++) {\n      consumeEarlyAccessCode(_commitments[i], _proofs[i], _roots[i], _nullifierHashes[i], _tos[i], _validationsArgs, _usersToWhitelist[i]);\n    }\n  }\n\n  function isWhitelisted(address _user) external view returns (bool) {\n    return usersWhitelisted[_user];\n  }\n\n  function addUserToWhitelist(address _user) public onlyOwner {\n    require(!usersWhitelisted[_user], \"User already whitelisted\");\n\n    usersWhitelisted[_user] = true;\n\n    emit UserAddedToWhitelist(_user, block.timestamp);\n  }\n\n  function removeUserFromWhitelist(address _user) public onlyOwner {\n    require(usersWhitelisted[_user], \"User not whitelisted\");\n\n    usersWhitelisted[_user] = false;\n    \n    emit UserRemovedFromWhitelist(_user, block.timestamp);\n  }\n}"
    },
    "contracts/useCases/whitelist/WhitelistFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {TalariaFactory} from \"../TalariaFactory.sol\";\nimport {Whitelist} from \"./Whitelist.sol\";\nimport \"../../TalariaProtocol.sol\";\n\ncontract WhitelistFactory is TalariaFactory {\n\n    event WhitelistCreated (address indexed whitelist);\n\n    constructor (\n        IVerifier _verifier,\n        IHasher _hasher,\n        uint32 _merkleTreeHeight\n    ) \n        TalariaFactory(_verifier, _hasher, _merkleTreeHeight)\n    {}\n\n    function create() override external returns (address) {\n        Whitelist w = new Whitelist(\n            defaultVerifier,\n            defaultHasher,\n            defaultMerkleTreeHeight,\n            msg.sender\n        );\n\n        emit WhitelistCreated(address(w));\n\n        return address(w);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}